{Problema de los Filosofos}
(* Con control de interbloqueos segun sea par o impar*)
program Filosofos;

const
   N = 5;
var 
   tenedor : array [1..N] of semaphore;  

process type Filosofo(id : integer);
var veces: integer;
begin
	repeat
		(* PENSANDO *)
    
		{PROTOCOLO ENTRADA}
		if (id mod 2) = 0 then begin {Filosofo par}
			wait(tenedor[id]);
			wait(tenedor[(id mod N) + 1]);
		end
		else begin  {Filosofo impar}
			wait(tenedor[(id mod N) + 1]);
			wait(tenedor[id]);
		end;

		{SECCIÃ“N CRITICA}  (* COMIENDO *)

		{PROTOCOLO DE SALIDA}
		signal(tenedor[id]);
		signal(tenedor[(id mod N) + 1]);
	forever
end; 

var
   Filo: array[1..N] of Filosofo;
   i : integer;


begin
   for i := 1 to N do initial(tenedor[i],1);
   cobegin
      for i := 1 to N do Filo[i](i);
   coend
end.


